Shortest remaining first algorithm choose the process with the shortest remaining time to execute next. The chosen process continue to execute until it completes or a new process is added that requires a smaller amount of time. It outperforms both FCFS and RR in terms of turnaround time and overhead because short process get handled quickly. For instance, assume a process whose job time is 120 ticks waits for 60 ticks then continue to execute until finish, the overhead will be 120+60/120 = 1.5. If the job time is 10 ticks, the overhead will be 60+10/10 = 7.  Thus, both average overhead and maximum overhead has improved.  It's limitation is that If short processes are continually added, long processes won't get a chance to execute. 

Least frequently used algorithm maintains a frequency table, which records how many time a page has been referenced. It finds the the page with the lowest frequency to evict. If a once frequently used page hasn't been used for a while, its frequency will be reduced gradually. This process is called aging.

It outperforms baseline algorithms as it keeps as many as frequently used pages as possible, thus reduce the possibility of page fault.